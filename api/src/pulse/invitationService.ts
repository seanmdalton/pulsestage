/**
 * Pulse Invitation Service
 * Handles sending pulse invitations via email
 */

import { PrismaClient, PulseChannel } from '@prisma/client';
import { getEmailService } from '../lib/email/emailService.js';
import { renderEmail } from '../lib/email/templates.js';
import PulseInvitationEmail from '../emails/PulseInvitationEmail.js';

export interface SendPulseInvitationsOptions {
  tenantId: string;
  questionId: string;
  userIds: string[];
  cohortName?: string;
}

export interface SendPulseInvitationsResult {
  sent: number;
  failed: number;
  errors: Array<{ userId: string; error: string }>;
}

/**
 * Send pulse invitations to specified users
 */
export async function sendPulseInvitations(
  prisma: PrismaClient,
  options: SendPulseInvitationsOptions
): Promise<SendPulseInvitationsResult> {
  const { tenantId, questionId, userIds, cohortName: _cohortName } = options;

  const result: SendPulseInvitationsResult = {
    sent: 0,
    failed: 0,
    errors: [],
  };

  // Get the question
  const question = await prisma.pulseQuestion.findUnique({
    where: { id: questionId },
  });

  if (!question) {
    throw new Error(`Question ${questionId} not found`);
  }

  // Get tenant info
  const tenant = await prisma.tenant.findUnique({
    where: { id: tenantId },
  });

  if (!tenant) {
    throw new Error(`Tenant ${tenantId} not found`);
  }

  // Get users with their primary teams
  const users = await prisma.user.findMany({
    where: {
      id: { in: userIds },
      tenantId,
    },
    include: {
      primaryTeam: true, // Include primary team for team association
    },
  });

  console.log(
    `ðŸ“§ Sending ${users.length} pulse invitations for question: "${question.text.substring(0, 50)}..."`
  );

  // Calculate expiration (7 days from now)
  const expiresAt = new Date();
  expiresAt.setDate(expiresAt.getDate() + 7);

  // Send to each user
  for (const user of users) {
    try {
      // Create invite record with unique token
      const invite = await prisma.pulseInvite.create({
        data: {
          tenantId,
          userId: user.id,
          teamId: user.primaryTeamId, // Associate invite with user's primary team
          questionId,
          channel: PulseChannel.EMAIL,
          expiresAt,
          status: 'PENDING',
          // token is auto-generated by default(uuid())
        },
      });

      // Get base URL from environment (API URL for response handling)
      const baseUrl = process.env.API_URL || process.env.BACKEND_URL || 'http://localhost:3000';

      // Render email template to HTML
      const { html, text } = await renderEmail(PulseInvitationEmail, {
        userName: user.name || user.email,
        questionText: question.text,
        scale: question.scale,
        token: invite.token,
        baseUrl,
        tenantName: tenant.name,
      });

      // Send email
      const emailService = getEmailService();
      await emailService.send({
        to: { email: user.email, name: user.name || undefined },
        subject: `Your Weekly Pulse `,
        html,
        text,
      });

      // Mark as sent
      await prisma.pulseInvite.update({
        where: { id: invite.id },
        data: {
          sentAt: new Date(),
          status: 'SENT',
        },
      });

      result.sent++;
    } catch (error) {
      console.error(`Failed to send pulse invite to ${user.email}:`, error);
      result.failed++;
      result.errors.push({
        userId: user.id,
        error: error instanceof Error ? error.message : 'Unknown error',
      });
    }
  }

  console.log(`[OK] Sent ${result.sent} invitations, ${result.failed} failed`);

  return result;
}

/**
 * Select a question for a given cohort (rotation logic)
 * Returns the next question in rotation, or a random question if no rotation state
 */
export async function selectQuestionForCohort(
  prisma: PrismaClient,
  tenantId: string,
  cohortName: string
): Promise<string | null> {
  // Get all active questions for this tenant
  const questions = await prisma.pulseQuestion.findMany({
    where: {
      tenantId,
      active: true,
    },
    orderBy: { createdAt: 'asc' },
  });

  if (questions.length === 0) {
    console.warn(`No active questions found for tenant ${tenantId}`);
    return null;
  }

  // For now, use simple round-robin based on cohort name
  // In production, you might want to track last-sent question per cohort
  const cohortIndex = parseInt(cohortName.split('-').pop() || '0');
  const questionIndex = cohortIndex % questions.length;

  return questions[questionIndex].id;
}

/**
 * Trigger pulse send for a specific cohort
 */
export async function triggerPulseForCohort(
  prisma: PrismaClient,
  tenantId: string,
  cohortName: string
): Promise<SendPulseInvitationsResult> {
  console.log(`ðŸŽ¯ Triggering pulse for tenant ${tenantId}, cohort ${cohortName}`);

  // Get cohort
  const cohort = await prisma.pulseCohort.findUnique({
    where: {
      tenantId_name: {
        tenantId,
        name: cohortName,
      },
    },
  });

  if (!cohort) {
    throw new Error(`Cohort ${cohortName} not found for tenant ${tenantId}`);
  }

  const userIds = JSON.parse(cohort.userIds as string) as string[];

  if (userIds.length === 0) {
    console.warn(`Cohort ${cohortName} has no users`);
    return { sent: 0, failed: 0, errors: [] };
  }

  // Select a question
  const questionId = await selectQuestionForCohort(prisma, tenantId, cohortName);

  if (!questionId) {
    throw new Error(`No question available for tenant ${tenantId}`);
  }

  // Send invitations
  return await sendPulseInvitations(prisma, {
    tenantId,
    questionId,
    userIds,
    cohortName,
  });
}
